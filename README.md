# Quiz Application Project

## Introduction

The goal of this project is to create a quiz application where one master and two or more players can play simultaneously on the same device. Every player has a button assigned. For each question, the fastest player gets to answer. If they do not give the correct answer, the second player gets a chance, and if they also answer incorrectly, the third player will have a turn, and so on. If no one provides the right answer, the game proceeds to the next question. The winner will be the player that at the end of the game will have the highest amount of correct answers with the lowest amount of wrong answers
## How the Game is Created

There are two different user roles: the **Master** and the **Player**.

The game starts when the Master creates a game. Some API calls will be made to the Trivia API ([Documentation](https://opentdb.com/api_config.php)).

### Trivia API Calls:

1. **Retrieve Token:**
   The first API call retrieves a token to avoid question repetitiveness.
   - Endpoint: `https://opentdb.com/api_token.php?command=request`
   - This token must be appended to the API GET call for question retrieval.

2. **Retrieve Questions:**
   The second API call retrieves the questions. The token must be provided in the URL as a parameter to avoid repetitive questions.
   - Endpoint: `https://opentdb.com/api.php?amount=25&token=YOURTOKENHERE`
   - By default, a game is composed of 25 questions (specified by the query string parameter `amount`).

3. **Retrieve Categories:**
   The third call retrieves the available categories.
   - Endpoint: `https://opentdb.com/api_category.php`
   - This call will not be made at every game start but will be done once a day to check if the categories stored in the database have changed. (Categories will be inserted by default if the category table is empty.)


## Technological Stack

### Database
MySQL - A light, open-source, stable, and fast DBMS. 
I've chosen MySQL because it has all the features I need 
for a project of this size, where the business logic
won't be related to the database (for example, with the usage of 
PL/SQL constructs like packages, functions, triggers, or stored
procedures).

## Backend
Java 17 with the Spring Boot framework - Spring Boot is one of
the most efficient frameworks for building an API.
I've chosen Spring Boot because it has many functionalities
to avoid writing boilerplate code. I will use Maven as
the dependency manager, and I will need the following dependencies
to create my API:
	1) Spring Web - Necessary to build a RESTful API with
	   Spring Boot. It also adds Tomcat as an embedded web server to
	   the project.
	2) Spring Data JPA - To interact with the database using 
	   JPA Repositories.
	3) MySQL Driver - To work with the MySQL database.
	4) Validation - To validate input data.
	5) Lombok - To avoid boilerplate code during class creation.
	6) Spring Security - To manage sign-in, sign-up, and method
	   access so players can see their scores and share the code with
	   the game master to join the game, because only master users 
	   can start games.
	7) MapStruct - To improve object-to-DTO and DTO-to-object mapping.
	8) Lombok MapStruct Binding - To make MapStruct and Lombok work
	   together.
	9) JSON Web Tokens (JWT) - To manage JWT token creation and
	decoding.
	10) Spring Reactive Web (WebFlux)** - To manage REST calls between
	 our API and the Trivia API.
	11) Quartz Scheduler - To schedule the job of updating categories once
		a day.


## Frontend
React 18.2.0 - React is an amazing framework when it comes to realize
reusable components. i will use react with the following dependencies
to help me with the implementations of the UI:
1) MaterialUI - the google component library that offers plenty of
 pre-built components.
2)Styled components - a library that helps me to manage the component
 styling directly inside components and to customize MaterialUI pre-built
 ones
 3) React Router - a library that helps me to show components under
 a certain url
 4) React Toastify - a library that helps me to show errors in a most
 attractive design
 5) Redux - a store manager that helps to manage data and dispatch API
 calls to the backend

## Entities
In this section i want to provide in detail what the entity classes will be, what are the relations between them.
### User(user_account)
- `Long id` - entity identifier, autogenerated in sequence
- `String username` - username to log in
- `String password` - password to log in
- `String gameCode` - autogenerated random string with letters and numbers
- `Role(Enum) role` - Player or Master 
- `Timestamp createdAt` - Creation timestamp
- `Timestamp updatedAt` - Update timestamp
### Game
- `Long id` - entity identifier, autogenerated in sequence
- `User master` - Many to one relationship with user entity, master that created the game
- `boolean open` - game playable true, game over false
- `Timestamp createdAt` - Creation timestamp
- `Timestamp updatedAt` - Update timestamp
### GamePlayers(game_players)
- `User player(player_id)` - Many to one relationship with user entity, player user id 
- `Game game(game_id)` - Many to one relationship with game entity, game id
- `Long insertionOrder` - insertion order
- `Timestamp createdAt` - Creation timestamp
- `Timestamp updatedAt` - Update timestamp
### Question
- `Long id` - entity identifier, autogenerated in sequence
- `Category category` - Many to one relationship, category of the question
- `String text` - text of the question
- `Timestamp createdAt` - Creation timestamp
- `Timestamp updatedAt` - Update timestamp
### GameQuestions
- `Game game(game_id)` - Many to one relationship, game id
- `Question question(question_id)` - Many to one relationship, Question id
- `Long insertionOrder` - insertion order
- `Timestamp createdAt` - Creation timestamp
- `Timestamp updatedAt` - Update timestamp

### Answer 
- `Long id` - entity identifier, autogenerated in sequence
- `String text` - Text of the answer
- `boolean correct` - correct or not
- `Question question` - Many to one relationship, Question id
- `Timestamp createdAt` - Creation timestamp
- `Timestamp updatedAt` - Update timestamp

### PlayerAnswers
- `User player` - Many to one relationship, player that answered
- `Answer answer` - Many to one relationship, answer id
- `Long insertionOrder` - insertion order
- `Timestamp createdAt` - Creation timestamp
- `Timestamp updatedAt` - Update timestamp
### GamePlayerResult
- `User player` - Many to one relationship, player id
- `Game game` - Many to one relationship, game id
- `boolean win` - win or loss
- `Timestamp createdAt` - Creation timestamp
- `Timestamp updatedAt` - Update timestamp



## API Methods
In this section, I want to provide in detail what the API methods of the backend will be, what parameters they need to retrieve or change the data, and how the response will be formatted.
The base URL of the API will be: **{{HOSTNAME}}/api/v1/quizapp/**

### Sign In method
- URL: `{{BASEURL}}/auth/login`
- HTTP method: POST
- Role allowed: unlogged
- Parameters: `{username:"username",password:"pwd"}`
- Response: `{token:"jwttoken"}`
- Purpose: to let the user sign in (if `active = true`) and generate a **JWT** that will be stored on frontend `localStorage`. The JWT will have the following extra claims: `username`, `gamecode`.

### Sign Up method
- URL: `{{BASEURL}}/auth/register`
- HTTP method: POST
- Role allowed: unlogged
- Parameters: `{username:"username",password:"pwd",role:"default player"}`
- Response: `{token:"jwttoken"}`
- Purpose: to register the user in the database and generate a **JWT** that will be stored on frontend `localStorage`. The JWT will have the following extra claims: `username`, `gamecode`. The user will be created in the database with the **Player** role as default. Only a **Master** can update the role to **Master**. The `gamecode` will be randomly generated.

### Update Role method
- URL: `{{BASEURL}}/users/updateRole/{:userId}`
- HTTP method: PUT
- Role allowed: Master
- Parameters: None
- Response: `{username:"username", gamecode:"gamecode",role:player}`
- Purpose: to change the user's role. If the user for whom the update is requested has the **Player** role, the role will be set to **Master**; vice versa, it will be set to **Player**.

### Get All Users method
- URL: `{{BASEURL}}/users/getUsers`
- HTTP method: GET
- Role allowed: Master
- Parameters: Paginator, `{username:"username", gamecode:"gamecode", role:"player", active:true}`
- Response: `{username:"username", gamecode:"gamecode", gamesPlayed:[], win:0, losses:0, active:true, role:player, correctAnswers:0, wrongAnswers:0}`
- Purpose: to let the **Master** see all users and filter them.

### Enable or Disable User method
- URL: `{{BASEURL}}/users/enableOrDisable/{:userId}?action=enable/disable`
- HTTP method: PUT
- Role allowed: Master
- Parameters: None
- Response: `{username:"username", gamecode:"gamecode", gamesPlayed:[], win:0, losses:0, active:true, role:player}`
- Purpose: to let the **Master** enable or disable a user.

### Delete User method
- URL: `{{BASEURL}}/users/delete/{:userId}`
- HTTP method: DELETE
- Role allowed: Master
- Parameters: None
- Response: None
- Purpose: to let the **Master** delete a user from the database.

### Create Game method
- URL: `{{BASEURL}}/game/createGame`
- HTTP method: POST
- Role allowed: Master
- Parameters: None
- Response: `{id:1, questions:[{id:1, answers:[{id:1, text:"text", correct:true}], answeredCorrectlyBy:null}], players:[], open:true}`
- Purpose: to create a game and retrieve all questions for the frontend. The `players` array will be empty because players will be added later. This method only creates the game and retrieves questions from the Trivia API to store them in the database.

### Get Open Game method
- URL: `{{BASEURL}}/game/getOpenGame`
- HTTP method: GET
- Role allowed: Master
- Parameters: None
- Response: `{id:1, questions:[{id:1, answers:[{id:1, text:"text", correct:true}], answeredCorrectlyBy:null}], players:[], open:true}`
- Purpose: to retrieve the current open game by the logged-in Master.

### Add Player method
- URL: `{{BASEURL}}/game/addPlayer/{:gameId}?gameCode=gameCode`
- HTTP method: POST
- Role allowed: Master
- Parameters: None
- Response: `{id:1, username:"username", gameCode:"gameCode"}`
- Purpose: to add a single user using their `gameCode`.

### Remove Player method
- URL: `{{BASEURL}}/game/removePlayer/{:gameId}?userId=userId`
- HTTP method: DELETE
- Role allowed: Master
- Parameters: None
- Response: `{id:1, username:"username", gameCode:"gameCode"}`
- Purpose: to remove a single user using their `userId`.

### Delete Game method
- URL: `{{BASEURL}}/game/deleteGame/{:gameId}`
- HTTP method: DELETE
- Role allowed: Master
- Parameters: None
- Response: None
- Purpose: to delete a game created by accident.

### Answer the Question method
- URL: `{{BASEURL}}/game/answerQuestion/{:questionId}?userId=1&answerId=1`
- HTTP method: POST
- Role allowed: Master
- Parameters: None
- Response: `[{id:1, questions:[{id:1, answers:[{id:1, text:"text"}]}], players:[]}]`
- Purpose: to submit an answer for a specific question.

### Close Game method
- URL: `{{BASEURL}}/game/closeGame/{:gameId}?winner=userId`
- HTTP method: PUT
- Role allowed: Master
- Parameters: None
- Response: `{id:1, username:"username", gameCode:"gameCode"}`
- Purpose: to end the game and return the winner.

### User Stats method
- URL: `{{BASEURL}}/users/getUserStats/{:gameId}`
- HTTP method: GET
- Role allowed: Player
- Parameters: None
- Response: `{id:1, gamesPlayed:[{win:true, loss:false, questions:[{id:1, text:"text", answers:[{id:1, text:"text", correct:false}]}]}], wins:1, losses:0, correctAnswers:0, gameCode:"gameCode"}`
- Purpose: to let the **Player** see their stats for all games played (only closed games).

## Pages
In this section, I want to provide a summary of each frontend page and its purpose.
The frontend base URL will be: **{{HOSTNAME}}/**

### Sign In Page
- URL: `{{BASEURL}}/signin`
- Role allowed: unlogged
- Parameters: None
- Description: Login page with username and password textboxes and a submit button. If the login is correct, the JWT and user state will be updated and stored in `localStorage`.
- Methods called:
	- (Unlogged)[[README#Sign In method]]

### Sign Up Page
- URL: `{{BASEURL}}/signup`
- Role allowed: unlogged
- Parameters: None
- Description: Register page with username and password textboxes and a submit button. If the registration is successful, the JWT and user state will be updated and stored in `localStorage`.
- Methods called:
	- (Unlogged)[[README#Sign up method]]

### Home Page
- URL: `{{BASEURL}}/`
- Role allowed: Master/Player
- Parameters: None
- Description: If the logged-in user is a **Master**, the current question of their open game will be displayed (only one game can be open at a time). If no games are open, there will be a button to create a new game. If the logged-in user is a **Player**, the stats screen will be shown.
- Methods called:
	- (Master)[[README#Get open game method]]
	- (Master)[[README#Create game method]]
	- (Player)[[README#User stats method]]

### Game Over
- URL: `{{BASEURL}}/game-over/:gameId`
- Role allowed: Master
- Parameters: `gameId` (number)
- Description: Ends the current game. The winner will be the user with the most accurate answers.
- Methods called:
	- (Master)[[README#Close game method]]

### 404
- URL: None
- Role allowed: All
- Parameters: None
- Description: Default page when the content is not found.
- Methods called: None
